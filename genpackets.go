package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

const HeaderWarning = `// WARNING: Do not edit! This file is auto-generated by Scripts/genpackets/gen.sh`

type TypeInfo struct {
	size                           int
	objcType                       string
	protoType                      string
	attributeString                string
	needsSpaceAfterType            bool
	fromStringMethod               string // only for xml
	fromStringMethodMayReturnError bool   // only for xml
}

type LineInfo struct {
	typeInfo       TypeInfo
	varName        string
	remainingFlag  bool   // only for bin
	xmlVarName     string // only for xml
	optional       bool   // only for xml
	nilReplacement string // only for xml
}

type ObjectInfo struct {
	linesInfo []LineInfo
	in        bool
	out       bool
	xml       bool
	data      bool
	className string
	packetId  int
}

var (
	Gtypes map[string]TypeInfo
)

func createTypes() {

	Gtypes = make(map[string]TypeInfo)

	types := map[string]TypeInfo{
		"uint8":        TypeInfo{1, "UInt8", "", "", true, "UInt8ValueWithError", true},
		"sint8":        TypeInfo{1, "SInt8", "", "", true, "SInt8ValueWithError", true},
		"uint16":       TypeInfo{2, "UInt16", "", "", true, "UInt16ValueWithError", true},
		"sint16":       TypeInfo{2, "SInt16", "", "", true, "SInt16ValueWithError", true},
		"uint32":       TypeInfo{4, "UInt32", "", "", true, "UInt32Value", false},
		"sint32":       TypeInfo{4, "SInt32", "", "", true, "SInt32Value", false},
		"uint64":       TypeInfo{8, "UInt64", "", "", true, "UInt64Value", false},
		"sint64":       TypeInfo{8, "SInt64", "", "", true, "SInt64Value", false},
		"float32":      TypeInfo{4, "Float32", "", "", true, "Float32Value", false},
		"float64":      TypeInfo{8, "Float64", "", "", true, "Float64Value", false},
		"bool":         TypeInfo{1, "BOOL", "", "", true, "UInt8ValueWithError", true},
		"char":         TypeInfo{1, "char", "", "", true, "UInt8ValueWithError", true},
		"string":       TypeInfo{0, "NSString *", "", "", false, "", false},
		"ucs2lestring": TypeInfo{0, "NSString *", "", "", false, "", false},
		"asciistring":  TypeInfo{0, "NSString *", "", "", false, "", false},
		"data":         TypeInfo{0, "NSData *", "", "", false, "", false},
		"node":         TypeInfo{0, "NSString *", "", "", false, "", false},
	}

	for protoType, value := range types {
		value.protoType = protoType
		Gtypes[protoType] = value
	}
}

func readLines(file *os.File) (lines []string, err error) {
	var (
		part   []byte
		prefix bool
	)

	reader := bufio.NewReader(file)
	buffer := bytes.NewBuffer(make([]byte, 0))
	for {
		if part, prefix, err = reader.ReadLine(); err != nil {
			break
		}
		buffer.Write(part)
		if !prefix {
			lines = append(lines, buffer.String())
			buffer.Reset()
		}
	}
	if err == io.EOF {
		err = nil
	}
	return
}

//
// Headers/footers
//

func writeHeaderHeaderBinOrXml(hFile *os.File, objName, baseClass string) {
	const header = `//
// %v.h
//
%v
//

#import "%v.h"

@interface %v : %v

`
	fmt.Fprintf(hFile, header, objName, HeaderWarning, baseClass, objName, baseClass)
}

func writeHeaderHeaderData(hFile *os.File, objName, baseClass string) {
	const header = `//
// %v.h
//
%v
//

#import "%v.h"

@interface %v : %v

`
	fmt.Fprintf(hFile, header, objName, HeaderWarning, baseClass, objName, baseClass)
}

func writeHeaderFooter(hFile *os.File) {
	const footer = `
@end
`
	fmt.Fprintf(hFile, footer)
}

func writeImplHeader(mFile *os.File, objName, baseClass string, obj ObjectInfo) {
	const (
		headerStart = `//
// %v.m
//
%v
//

#import "%v.h"
#import "NSError+FXUtils.h"`

		headerEnd = `

@implementation %v

`

		headerXml = `
#import "NSString+NumberConversions.h"
#import "TBXML.h"`
	)

	fmt.Fprintf(mFile, headerStart, objName, HeaderWarning, objName)
	if obj.xml {
		fmt.Fprintf(mFile, headerXml)
	}
	fmt.Fprintf(mFile, headerEnd, objName)
}

func writeImplFooter(mFile *os.File) {
	const footer = `
@end
`
	fmt.Fprintf(mFile, footer)
}

func writePropertiesDecl(hFile *os.File, linesInfo []LineInfo) {
	for _, lineInfo := range linesInfo {
		fmt.Fprintf(hFile, "@property (nonatomic")
		if len(lineInfo.typeInfo.attributeString) == 0 {
			fmt.Fprintf(hFile, ")")
		} else {
			fmt.Fprintf(hFile, ", %v)", lineInfo.typeInfo.attributeString)
		}
		fmt.Fprintf(hFile, " ")
		fmt.Fprintf(hFile, "%v", lineInfo.typeInfo.objcType)
		if lineInfo.typeInfo.needsSpaceAfterType {
			fmt.Fprintf(hFile, " ")
		}
		fmt.Fprintf(hFile, "%v;\n", lineInfo.varName)
	}
}

//
// Packet IDs
//

func writePackedIdImpl(mFile *os.File, packetId int) {
	fmt.Fprintf(mFile, "+ (UInt8) packetId\n")
	fmt.Fprintf(mFile, "{\n")
	fmt.Fprintf(mFile, "    return %v;\n", packetId)
	fmt.Fprintf(mFile, "}\n")
	fmt.Fprintf(mFile, "\n")
}

func writeXmlPackedIdImpl(mFile *os.File, packetId int) {
	fmt.Fprintf(mFile, "+ (UInt32) xmlPacketId\n")
	fmt.Fprintf(mFile, "{\n")
	fmt.Fprintf(mFile, "    return %v;\n", packetId)
	fmt.Fprintf(mFile, "}\n")
	fmt.Fprintf(mFile, "\n")
}

//
// Binary - parse
//

func writeParseBodyDataImpl(mFile *os.File, obj ObjectInfo) {

	var totalSize int = 0
	for _, lineInfo := range obj.linesInfo {
		totalSize += lineInfo.typeInfo.size
	}

	fmt.Fprintf(mFile, "- (BOOL) parseBodyData:(NSData *)data withError:(NSError **)error\n")
	fmt.Fprintf(mFile, "{\n")

	if len(obj.linesInfo) != 0 {
		if totalSize != 0 {
			fmt.Fprintf(mFile, "    if ([data length] < %v) {\n", totalSize)
			fmt.Fprintf(mFile, "        if (error) {\n")
			fmt.Fprintf(mFile, "            *error = [NSError errorWithLocalizedDescription:NSLocalizedString(@\"Wrong data size\", nil)];\n")
			fmt.Fprintf(mFile, "        }\n")
			fmt.Fprintf(mFile, "        return NO;\n")
			fmt.Fprintf(mFile, "    }\n")
			fmt.Fprintf(mFile, "\n")
		}
		fmt.Fprintf(mFile, "    const UInt8 *bytes = [data bytes];\n")
		fmt.Fprintf(mFile, "\n")
	}

	var offset int = 0

	for i, lineInfo := range obj.linesInfo {

		if i == len(obj.linesInfo)-1 && lineInfo.remainingFlag {
			if lineInfo.typeInfo.protoType == "data" {
				fmt.Fprintf(mFile, "    _%v = [NSData dataWithBytes:(bytes + %v)  length:([data length] - %v)];\n", lineInfo.varName, offset, offset)
			} else {
				var encoding string
				if lineInfo.typeInfo.protoType == "ucs2lestring" {
					encoding = "NSUTF16LittleEndianStringEncoding"
				} else if lineInfo.typeInfo.protoType == "asciistring" {
					encoding = "NSASCIIStringEncoding"
				} else {
					fmt.Printf("%v: unsupported type \"%v\" for field with \"remaining\" flag (only ucs2lestring/asciistring types are supported)\n", obj.className, lineInfo.typeInfo.protoType)
					continue
				}
				fmt.Fprintf(mFile, "    _%v = [[NSString alloc] initWithBytes:(bytes + %v) length:([data length] - %v) encoding:%v];\n", lineInfo.varName, offset, offset, encoding)
			}

		} else {
			if lineInfo.remainingFlag {
				fmt.Printf("%v: \"remaining\" flag ignored\n", obj.className)
				continue
			} else {
				fmt.Fprintf(mFile, "    memcpy(&_%v, bytes + %v, %v);\n", lineInfo.varName, offset, lineInfo.typeInfo.size)
				offset += lineInfo.typeInfo.size
			}
		}
	}
	fmt.Fprintf(mFile, "\n")
	fmt.Fprintf(mFile, "    return YES;\n")
	fmt.Fprintf(mFile, "}\n")
	fmt.Fprintf(mFile, "\n")
}

//
// Binary - make
//

func writeAppendToBodyDataImpl(mFile *os.File, linesInfo []LineInfo) {

	fmt.Fprintf(mFile, "- (void) appendBodyToData:(NSMutableData *)data\n")
	fmt.Fprintf(mFile, "{\n")

	for _, lineInfo := range linesInfo {
		switch lineInfo.typeInfo.protoType {
		case "string", "ucs2lestring":
			fmt.Fprintf(mFile, "    [data appendData:[_%v dataUsingEncoding:NSUTF16LittleEndianStringEncoding]];\n", lineInfo.varName)
		case "asciistring":
			fmt.Fprintf(mFile, "    [data appendData:[_%v dataUsingEncoding:NSASCIIStringEncoding]];\n", lineInfo.varName)
		default:
			fmt.Fprintf(mFile, "    [data appendBytes:&_%v length:%v];\n", lineInfo.varName, lineInfo.typeInfo.size)
		}
	}

	fmt.Fprintf(mFile, "}\n")
	fmt.Fprintf(mFile, "\n")
}

//
// XML - parse from data
//

func writeParseXmlStringImpl(mFile *os.File, linesInfo []LineInfo) {

	const header1 = `
- (BOOL) parseXmlString:(NSString *)xmlString withError:(NSError **)error
{`
	const header2 = `
    TBXML *xml = [TBXML newTBXMLWithXMLString:xmlString error:error];    
    if (error && *error) {
        return NO;
    }

    TBXMLElement *root = xml.rootXMLElement;

    NSError *internalError = nil;

`
	fmt.Fprintf(mFile, header1)

	if len(linesInfo) != 0 {
		fmt.Fprintf(mFile, header2)
	}

	for i, lineInfo := range linesInfo {
		var valueOfAttributeString string

		if !lineInfo.optional {
			valueOfAttributeString = fmt.Sprintf("[TBXML valueOfAttributeNamed:@\"%v\" forElement:root error:&internalError]", lineInfo.xmlVarName)
		} else {
			valueOfAttributeString = fmt.Sprintf("[TBXML valueOfAttributeNamed:@\"%v\" forElement:root error:nil]", lineInfo.xmlVarName)
		}

		if lineInfo.nilReplacement != "" {

			fmt.Fprintf(mFile, "    NSString *%vString = %v;\n", lineInfo.varName, valueOfAttributeString)
			fmt.Fprintf(mFile, "    if ([%vString length] == 0) {\n        %vString = @\"%v\";\n    }\n", lineInfo.varName, lineInfo.varName, lineInfo.nilReplacement)
			valueOfAttributeString = fmt.Sprintf("%vString", lineInfo.varName)
		}

		if lineInfo.typeInfo.fromStringMethodMayReturnError {
			fmt.Fprintf(mFile, "    _%v = [%v %v:&internalError];\n", lineInfo.varName, valueOfAttributeString, lineInfo.typeInfo.fromStringMethod)
		} else {
			if len(lineInfo.typeInfo.fromStringMethod) != 0 {
				fmt.Fprintf(mFile, "    _%v = [%v %v];\n", lineInfo.varName, valueOfAttributeString, lineInfo.typeInfo.fromStringMethod)
			} else {
				fmt.Fprintf(mFile, "    _%v = %v;\n", lineInfo.varName, valueOfAttributeString)
			}
		}
		if !lineInfo.optional {
			fmt.Fprintf(mFile, "    if (internalError) {\n")
			fmt.Fprintf(mFile, "        LogWarningf(@\"Can't parse attribute \\\"%v\\\": %%@\", internalError);\n", lineInfo.xmlVarName)
			fmt.Fprintf(mFile, "        internalError = nil;\n")
			fmt.Fprintf(mFile, "    }\n")
		}

		if i != len(linesInfo)-1 {
			fmt.Fprintf(mFile, "\n")
		}
	}
	fmt.Fprintf(mFile, "\n")
	fmt.Fprintf(mFile, "    return YES;\n")
	fmt.Fprintf(mFile, "}\n")
	fmt.Fprintf(mFile, "\n")
}

//
// XML - parse from element
//

func writeInitWithXmlElementDecl(hFile *os.File) {
	fmt.Fprintf(hFile, "struct _TBXMLElement;\n")
	fmt.Fprintf(hFile, "- (id) initWithXmlElement:(struct _TBXMLElement *)root withError:(NSError **)error;\n")
	fmt.Fprintf(hFile, "\n")
}

func writeInitWithXmlElementImpl(mFile *os.File, linesInfo []LineInfo) {

	const header = `
- (id) initWithXmlElement:(TBXMLElement *)root withError:(NSError **)error
{
    if ((self = [super init]))
    {
        NSError *internalError = nil;

`
	fmt.Fprintf(mFile, header)

	for i, lineInfo := range linesInfo {
		var valueOfAttributeString string
		if !lineInfo.optional {
			valueOfAttributeString = fmt.Sprintf("[TBXML valueOfAttributeNamed:@\"%v\" forElement:root error:&internalError]", lineInfo.xmlVarName)
		} else {
			valueOfAttributeString = fmt.Sprintf("[TBXML valueOfAttributeNamed:@\"%v\" forElement:root error:nil]", lineInfo.xmlVarName)
		}

		if lineInfo.typeInfo.fromStringMethodMayReturnError {
			fmt.Fprintf(mFile, "        _%v = [%v %v:&internalError];\n", lineInfo.varName, valueOfAttributeString, lineInfo.typeInfo.fromStringMethod)
		} else {
			if len(lineInfo.typeInfo.fromStringMethod) != 0 {
				fmt.Fprintf(mFile, "        _%v = [%v %v];\n", lineInfo.varName, valueOfAttributeString, lineInfo.typeInfo.fromStringMethod)
			} else {
				fmt.Fprintf(mFile, "        _%v = %v;\n", lineInfo.varName, valueOfAttributeString)
			}
		}
		if !lineInfo.optional {
			fmt.Fprintf(mFile, "        if (internalError) {\n")
			fmt.Fprintf(mFile, "            LogWarningf(@\"Can't parse attribute \\\"%v\\\": %%@\", internalError);\n", lineInfo.xmlVarName)
			fmt.Fprintf(mFile, "            internalError = nil;\n")
			fmt.Fprintf(mFile, "        }\n")
		}
		if i != len(linesInfo)-1 {
			fmt.Fprintf(mFile, "\n")
		}
	}
	fmt.Fprintf(mFile, "    }\n")
	fmt.Fprintf(mFile, "    return self;\n")
	fmt.Fprintf(mFile, "}\n")
	fmt.Fprintf(mFile, "\n")
}

//
// XML - create
//

func writeMakeXmlDataDecl(hFile *os.File) {
	fmt.Fprintf(hFile, "- (NSData *) makeXmlData;\n")
	fmt.Fprintf(hFile, "\n")
}

func writeMakeXmlDataImpl(mFile *os.File, linesInfo []LineInfo) {
	fmt.Fprintf(mFile, "- (NSData *) makeXmlData\n")
	fmt.Fprintf(mFile, "{\n")
	fmt.Fprintf(mFile, "    NSMutableString *string = [NSMutableString new];\n")
	fmt.Fprintf(mFile, "\n")
	fmt.Fprintf(mFile, "    [string appendString:@\"<P\"];\n")

	for _, lineInfo := range linesInfo {

		specifier := ""
		cast := ""
		switch lineInfo.typeInfo.protoType {
		case "sint8", "sint16":
			specifier = "%d"
		case "sint32":
			specifier = "%d"
			cast = "(int)"
		case "uint8", "uint16", "bool":
			specifier = "%u"
		case "uint32":
			specifier = "%u"
			cast = "(unsigned int)"
		case "uint64":
			specifier = "%llu"
		case "char":
			specifier = "%c"
		case "sint64":
			specifier = "%lld"
		case "float32", "float64":
			specifier = "%f"
		default:
			specifier = "%@"
		}

		format := fmt.Sprintf("%v=\\\"%v\\\"", lineInfo.xmlVarName, specifier)
		fmt.Fprintf(mFile, "    [string appendFormat:@\" %v\", %v_%v];\n", format, cast, lineInfo.varName)
	}

	fmt.Fprintf(mFile, "    [string appendString:@\"/>\"];\n")
	fmt.Fprintf(mFile, "\n")
	fmt.Fprintf(mFile, "    return [string dataUsingEncoding:NSUTF16LittleEndianStringEncoding];\n")
	fmt.Fprintf(mFile, "}\n")
	fmt.Fprintf(mFile, "\n")
}

//----------------------------------------------

func genObject(obj ObjectInfo) {

	var baseClass string
	var prefix string
	switch {
	case obj.in && !obj.xml:
		baseClass = "DrResponse"
		prefix = baseClass
	case obj.out && !obj.xml:
		baseClass = "DrRequest"
		prefix = baseClass
	case obj.in && obj.xml:
		baseClass = "DrResponseTerminalXML"
		prefix = "DrResponse"
	case obj.out && obj.xml:
		baseClass = "DrRequestTerminalXML"
		prefix = "DrRequest"
	case obj.data:
		baseClass = "DrObject"
		prefix = "DrObject"
	}
	objName := prefix + obj.className

	hFileName := objName + ".h"
	hFile, err := os.Create(hFileName)
	if err != nil {
		log.Fatalf("Can't create file %v", hFileName)
	}

	if obj.data {
		writeHeaderHeaderData(hFile, objName, baseClass)
		writeInitWithXmlElementDecl(hFile)
	} else {
		writeHeaderHeaderBinOrXml(hFile, objName, baseClass)
	}
	writePropertiesDecl(hFile, obj.linesInfo)
	writeHeaderFooter(hFile)
	hFile.Close()

	mFileName := objName + ".m"
	mFile, err := os.Create(mFileName)
	if err != nil {
		log.Fatalf("Can't create file %v", mFileName)
	}

	writeImplHeader(mFile, objName, baseClass, obj)
	if obj.data {
		writeInitWithXmlElementImpl(mFile, obj.linesInfo)
	} else if !obj.xml {
		writePackedIdImpl(mFile, obj.packetId)
		if obj.in {
			writeParseBodyDataImpl(mFile, obj)
		}
		if obj.out {
			writeAppendToBodyDataImpl(mFile, obj.linesInfo)
		}
	} else {
		writeXmlPackedIdImpl(mFile, obj.packetId)
		if obj.in {
			writeParseXmlStringImpl(mFile, obj.linesInfo)
		}
		if obj.out {
			writeMakeXmlDataImpl(mFile, obj.linesInfo)
		}
	}
	writeImplFooter(mFile)
	mFile.Close()
}

func parseXmlLines(fileName string, lines []string) (linesInfo []LineInfo) {
	for i, line := range lines {
		comps := strings.Fields(line)
		if len(comps) < 3 {
			fmt.Printf("%v:%v: Can't parse line: \"%v\"\n", fileName, i, line)
			continue
		}

		index := 0
		optional := false
		nilReplacement := ""

		if strings.Contains(comps[0], "optional") {
			if len(comps) < 4 {
				fmt.Printf("%v:%v: Can't parse line: \"%v\"\n", fileName, i, line)
				continue
			} else {

				nilReplacmentOption := strings.TrimPrefix(comps[0], "optional")
				if strings.HasPrefix(nilReplacmentOption, "(nil=") && strings.HasSuffix(nilReplacmentOption, ")") {
					nilReplacmentOption = strings.TrimPrefix(nilReplacmentOption, "(nil=")
					nilReplacmentOption = strings.TrimSuffix(nilReplacmentOption, ")")
					nilReplacement = nilReplacmentOption
				}

				optional = true
				index++
			}
		}

		typeString := comps[index]
		typeInfo, ok := Gtypes[typeString]
		if !ok {
			fmt.Printf("%v:%v: Unknown type %v\n", fileName, i, typeString)
			continue
		}

		xmlVarName := comps[index+1]
		varName := comps[index+2]

		lineInfo := LineInfo{typeInfo, varName, false, xmlVarName, optional, nilReplacement}
		linesInfo = append(linesInfo, lineInfo)
	}
	return
}

func parseBinLines(fileName string, lines []string) (linesInfo []LineInfo) {
	for i, line := range lines {
		comps := strings.Fields(line)
		if len(comps) < 2 {
			fmt.Printf("%v:%v: Can't parse line: \"%v\"\n", fileName, i, line)
			continue
		}

		index := 0
		remaining := false
		if comps[0] == "remaining" {
			if len(comps) < 3 {
				fmt.Printf("%v:%v: Can't parse line: \"%v\"\n", fileName, i, line)
				continue
			} else {
				remaining = true
				index++
			}
		}

		typeString := comps[index]
		typeInfo, ok := Gtypes[typeString]
		if !ok {
			fmt.Printf("%v:%v: Unknown type %v\n", fileName, i, typeString)
			continue
		}

		varName := comps[index+1]

		lineInfo := LineInfo{typeInfo, varName, remaining, "", false, ""}
		linesInfo = append(linesInfo, lineInfo)
	}
	return
}

func parseObj(fileName string, startLineIndex, endLineIndex int, allLines []string) {
	if endLineIndex-startLineIndex < 1 {
		fmt.Printf("Can't parse object at lines %v-%v\n", startLineIndex, endLineIndex)
		return
	}

	var objInfo ObjectInfo

	lines := allLines[startLineIndex:endLineIndex]
	startLine := lines[0]
	comps := strings.Fields(startLine)
	for _, comp := range comps {
		if comp == "in" {
			objInfo.in = true
		} else if comp == "out" {
			objInfo.out = true
		} else if comp == "xml" {
			objInfo.xml = true
		} else if comp == "data" {
			objInfo.data = true
		}
	}

	if (objInfo.data && len(comps) < 2) || (!objInfo.data && len(comps) < 3) {
		fmt.Printf("Can't parse object header line %v\n", startLineIndex)
	}

	objInfo.className = comps[0]
	if !objInfo.data {
		objInfo.packetId, _ = strconv.Atoi(comps[1])
	}

	lines = lines[1:len(lines)]

	if objInfo.xml {
		objInfo.linesInfo = parseXmlLines(fileName, lines)
	} else {
		objInfo.linesInfo = parseBinLines(fileName, lines)
	}

	// Do generation
	genObject(objInfo)
}

func usage() {
	fmt.Printf("usage: %v <objFile>\n", filepath.Base(os.Args[0]))
}

func main() {

	// Check arguments

	if len(os.Args) == 1 || os.Args[1] == "-h" || os.Args[1] == "--help" {
		usage()
		os.Exit(0)
	}

	if len(os.Args) < 2 {
		log.Fatalf("missing object file")
	}

	fileName := os.Args[1]

	file, err := os.Open(fileName)
	if err != nil {
		log.Fatalf("Can't open file %v\n", fileName)
	}
	defer file.Close()

	lines, err := readLines(file)
	if err != nil {
		log.Fatalf("Can't read lines from file %v\n", fileName)
	}

	var filteredLines []string
	for _, line := range lines {
		trimmedLine := strings.Trim(line, " \t")
		if len(trimmedLine) == 0 {
			continue
		} else if trimmedLine[:1] == "#" || (len(trimmedLine) >= 2 && trimmedLine[:2] == "//") {
			continue
		} else {
			filteredLines = append(filteredLines, trimmedLine)
		}
	}

	lines = filteredLines

	var indices []int
	indices = append(indices, 0)
	for i, line := range lines {
		if strings.Contains(line, "}") {
			indices = append(indices, i+1)
		}
	}

	createTypes()

	for i, index := range indices {
		if i == len(indices)-1 {
			break
		} else {
			nextIndex := indices[i+1] - 1
			parseObj(fileName, index, nextIndex, lines)
		}
	}
}
